// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	PostProcessBloom.usf: PostProcessing bloom
=============================================================================*/

#include "Common.usf"
#include "PostProcessCommon.usf"

// for VisualizeBloomOverlayPS
// xyz:Bloom1Tint.rgb, w:unused
float4 ColorScale1;

// vertex shader entry point
void MainPostprocessCommonVS(
	in float4 InPosition : ATTRIBUTE0,
	in float2 InTexCoord : ATTRIBUTE1,
	out float4 OutTexCoord : TEXCOORD0,
	out float4 OutPosition : SV_POSITION
	)
{
	DrawRectangle(InPosition, InTexCoord, OutPosition, OutTexCoord.xy);
	OutTexCoord.zw =  OutPosition.xy;
}

void VisualizeBloomSetupPS(
	  float4 UVAndScreenPos : TEXCOORD0
	, out float4 OutColor : SV_Target0)
{
	float2 UV = UVAndScreenPos.xy;

	OutColor = 0;

	int2 PixelPos = (int2)ComputePixelPosCenter(UVAndScreenPos.zw, true);

	int2 ViewportCenter = (int2)(ViewportRect.xy + ViewportSize / 2);

	// cross in x and y
//	bool bMask = ViewportCenter.x == PixelPos.x || ViewportCenter.y == PixelPos.y;
	// vertical line at viewport center
	bool bMask = ViewportCenter.x == PixelPos.x;

	if(bMask)
	{
		OutColor = 20;
	}
}

void VisualizeBloomOverlayPS(
	  float4 UVAndScreenPos : TEXCOORD0
	, out float4 OutColor : SV_Target0)
{
	float2 UV = UVAndScreenPos.xy;
	
	float3 LDRColor = Texture2DSample(PostprocessInput0, PostprocessInput0Sampler, UV).rgb;
	
	int2 ViewportCenter = (int2)(ViewportRect + ViewportSize / 2);

	float2 UVLinePos = float2(UV.x, ViewportCenter.y * PostprocessInput0Size.w);

	float3 NonBloomColor = Texture2DSampleLevel(PostprocessInput1, PostprocessInput1Sampler, UVLinePos, 0).rgb;

	float3 BloomColor;
	{
		float4 CombinedBloom = Texture2DSample(PostprocessInput2, PostprocessInput2Sampler, UVLinePos);
		float3 BloomDirtMaskColor = 0;
		BloomColor = CombinedBloom.rgb * (ColorScale1.rgb + BloomDirtMaskColor); 
	}

	float NonBloomValue = Luminance(NonBloomColor);
	float BloomValue = Luminance(BloomColor);

	float CompareY = lerp(1.1f, -0.1f, UV.y);

	bool bNonBloom = NonBloomValue > CompareY;
	bool bBloom = BloomValue > CompareY;
	bool bOutside = CompareY < 0 || CompareY > 1;

	OutColor = 0.1f;

	FLATTEN if(bNonBloom)
	{
		OutColor.rgb = 0.3f;
	}

	FLATTEN if(bBloom)
	{
		OutColor.rgb = float3(0, 1, 0);
	}

	FLATTEN if(bOutside)
	{
		OutColor.rgb = float3(0, 0, 0);
	}
	
	// for debugging: show LDR scene color
//	OutColor.rgb = LDRColor;
}

// vertex shader entry point
void MainVS(
	in float4 InPosition : ATTRIBUTE0,
	in float2 InTexCoord : ATTRIBUTE1,
	out float4 OutTexCoord : TEXCOORD0,
	out float OutExposureScale : TEXCOORD1,
	out float4 OutPosition : SV_POSITION
	)
{
	MainPostprocessCommonVS(InPosition, InTexCoord, OutTexCoord, OutPosition);

#if FEATURE_LEVEL >= FEATURE_LEVEL_SM5
	// texture can be GWhiteTexture which is 1x1. It's important we don't read outside bounds.
	OutExposureScale = EyeAdaptation.Load(int3(0, 0, 0)).r;
#else
	OutExposureScale = 1;
#endif
}

// x:BloomThreshold, yz:unused, w:ExposureScale (useful if eyeadaptation is locked)
float4 BloomThreshold;
// -----------------------------
// bloom threshold
void MainPS(
	  float4 UVAndScreenPos : TEXCOORD0
	, float InExposureScale : TEXCOORD1
	, out float4 OutColor : SV_Target0)
{
	float2 UV = UVAndScreenPos.xy;

	half4 SceneColor = Texture2DSample(PostprocessInput0, PostprocessInput0Sampler, UV);

	// clamp to avoid artifacts from exceeding fp16 through framebuffer blending of multiple very bright lights
	SceneColor.rgb = min(float3(256 * 256, 256 * 256, 256 * 256), SceneColor.rgb);
	
	half3 LinearColor = SceneColor.rgb;

	float ExposureScale = InExposureScale;

#if NO_EYEADAPTATION_EXPOSURE_FIX 
	ExposureScale = BloomThreshold.w;
#endif

	// todo: make this adjustable (e.g. LUT)
	half TotalLuminance = Luminance( LinearColor ) * ExposureScale;
	half BloomLuminance = TotalLuminance - BloomThreshold.x;
	// mask 0..1
	half BloomAmount = saturate(BloomLuminance / 2.0f);

	OutColor = float4(BloomAmount * LinearColor, 0);
}


