// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
 PlanarReflectionShared.usf
=============================================================================*/

// World space reflection plane, normalized
float4 ReflectionPlane;

// Used to transform normals into the mirrored space
float3x4 InverseTransposeMirrorMatrix;

// x = scale for plane distance fading, y = bias for plane distance fading, z = controls normal distortion strength
float3 PlanarReflectionParameters;

// x = scale for angle fading, y = bias for angle fading
float2 PlanarReflectionParameters2;

// Projection matrix that was used to capture PlanarReflectionTexture
float4x4 ProjectionWithExtraFOV;

Texture2D PlanarReflectionTexture;
SamplerState PlanarReflectionSampler;

float4 ComputePlanarReflections(float3 WorldPosition, float3 WorldNormal, SamplerState SharedClampSampler)
{
	float4 OutPlanarReflection = 0;

	float PlaneDistance = dot(ReflectionPlane, float4(WorldPosition, -1));
	float DistanceFade = 1 - saturate(abs(PlaneDistance) * PlanarReflectionParameters.x + PlanarReflectionParameters.y);

	BRANCH
	if (DistanceFade > 0)
	{
		// CameraToPixel in the main view is what we used as ReflectionVector when rendering the reflection pass to PlanarReflectionTexture
		float3 CameraToPixel = normalize(WorldPosition - View.WorldCameraOrigin);
		// Reflect the effective ReflectionVector in mirrored space to get the original camera vector
		float3 MirroredCameraVector = reflect(CameraToPixel, -ReflectionPlane.xyz);
		// Transform the GBuffer normal into mirrored space
		float3 MirroredNormal = mul(WorldNormal, (float3x3)InverseTransposeMirrorMatrix);
		// Reflect the original camera vector across the GBuffer normal in mirrored space
		float3 MirroredReflectionVectorOffNormal = reflect(MirroredCameraVector, MirroredNormal);
		// At this point we have a new reflection vector off of the GBuffer normal, and we need to approximate its intersection with the scene
		// An accurate intersection would ray trace the planar reflection depth buffer
		// As an approximation we are just intersecting with a user defined sphere
		float3 VirtualReflectionSpherePosition = WorldPosition + MirroredReflectionVectorOffNormal * PlanarReflectionParameters.z;
		// Transform the intersection position into view space
		float3 ViewVirtualReflectionSpherePosition = mul(float4(VirtualReflectionSpherePosition + View.PreViewTranslation.xyz, 1), View.TranslatedWorldToView).xyz;
		// Transform the intersection position into clip space using the same projection matrix used to render PlanarReflectionTexture
		float4 ClipVirtualReflectionSpherePosition = mul(float4(ViewVirtualReflectionSpherePosition, 1), ProjectionWithExtraFOV);
		// Compute viewport UVs from clip space position.  
		// Note not using View.ScreenPositionScaleBias because PlanarReflectionTexture is exactly sized with the viewport, unlike the scene render targets
		float2 ViewportUV = ClipVirtualReflectionSpherePosition.xy / ClipVirtualReflectionSpherePosition.w * float2(.5f, -.5f) + .5f;

		float AngleFade = saturate(dot(ReflectionPlane.xyz, WorldNormal) * PlanarReflectionParameters2.x + PlanarReflectionParameters2.y);
		float FinalFade = DistanceFade * AngleFade;

#if SUPPORTS_INDEPENDENT_SAMPLERS
		OutPlanarReflection.rgb = Texture2DSampleLevel(PlanarReflectionTexture, SharedClampSampler, ViewportUV, 0).rgb * FinalFade;
#else
		OutPlanarReflection.rgb = Texture2DSampleLevel(PlanarReflectionTexture, PlanarReflectionSampler, ViewportUV, 0).rgb * FinalFade;
#endif
		OutPlanarReflection.a = FinalFade;
	}

	return OutPlanarReflection;
}
