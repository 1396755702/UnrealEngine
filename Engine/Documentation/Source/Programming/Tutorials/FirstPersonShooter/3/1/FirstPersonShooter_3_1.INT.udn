Availability: Docs
Title: 3.1 - Adding Projectiles to your Game
Crumbs: %ROOT%, Programming, Programming/Tutorials/FirstPersonShooter, Programming/Tutorials/FirstPersonShooter/3
Description: Learn how to add projectiles to your First Person Shooter project.
SkillLevel: Beginner
Version: 4.11

[VAR:Steps]
[OBJECT:Navigation]
	[PARAM:previous]
	[/PARAM]
	[PARAM:current]
	[/PARAM]
	[PARAM:home]
		[Section Home](Programming/Tutorials/FirstPersonShooter/3)
	[/PARAM]
	[PARAM:next]
		[Next Step](Programming/Tutorials/FirstPersonShooter/3/2)
	[/PARAM]
[/OBJECT]
[/VAR]

%Steps%

Now that we've set-up our character, it's time to implement a projectile weapon so that when we fire, a simple grenade-like projectile will shoot from the center of the screen and fly until it collides with the world. During this step, we're going to add input and create a new code class for our projectile.

## Adding Fire Action Mapping

1.	In the **Edit** menu, click on **Project Settings**.

1.	Under the **Engine** heading on the left side of the **Project Settings** tab, click on **Input**.

1.	Under **Bindings**, click on the plus sign next to **Action Mappings**.

1.	Click on the arrow to the left of **Action Mappings**.

1.	Type "Fire" into the text field that appears, then click on the arrow to the left of the text box to expand the action binding options.

1.	In the dropdown menu, select **Left Mouse Button** from the **Mouse** dropdown list.

1.	Your input settings should now look like the following:

	![](ActionMapping.png)

1.	Close the **Project Settings** menu.

## Adding a Projectile Class

1.	In the File menu, select **New C++ Class...** to choose your new parent class.

1.	The **Choose Parent Class** menu will open. Scroll down, select **Actor** as the parent class and click **Next**.

	![](AddProjectileClass.png)

1.	Name the new class "FPSProjectile," then click **Create**.

	![](CreateProjectileClass.png)

## Adding a USphere Component

1.	Locate the `FPSProjectile` class header in the **Solution Explorer** and open `FPSProjectile.h`.

1.	Add a reference to a `USphereComponent` in the `FPSProjectile` interface.

		// Sphere collision component
		UPROPERTY(VisibleDefaultsOnly, Category = Projectile)
		USphereComponent* CollisionComp;

1.	`FPSProjectile.h` should now look like the following:

		// Fill out your copyright notice in the Description page of Project Settings.
		
		#pragma once
		
		#include "GameFramework/Actor.h"
		#include "FPSProjectile.generated.h"
		
		UCLASS()
		class FPSPROJECT_API AFPSProjectile : public AActor
		{
			GENERATED_BODY()
			
		public:	
			// Sets default values for this actor's properties
			AFPSProjectile();
		
			// Called when the game starts or when spawned
			virtual void BeginPlay() override;
			
			// Called every frame
			virtual void Tick( float DeltaSeconds ) override;
		
			// Sphere collision component
			UPROPERTY(VisibleDefaultsOnly, Category = Projectile)
			USphereComponent* CollisionComponent;
			
		};

1.	Locate the `FPSProjectile` class implementation file in the **Solution Explorer** and open `FPSProjectile.cpp`.

1.	Add the following code to the `AFPSProjectile` constructor in `FPSProjectile.cpp`:

		// use a sphere as a simple collision representation
		CollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComponent"));
		// set the sphere's collision radius
		CollisionComponent->InitSphereRadius(15.0f);
		// set the root component to be the collision component
		RootComponent = CollisionComponent;

		[REGION:note]
		You're making `CollisionComponent` a `RootComponent` since the simulation will drive it.
		[/REGION]

1. `FPSProjectile.cpp` should now look like the following:

		// Fill out your copyright notice in the Description page of Project Settings.
		
		#include "FPSProject.h"
		#include "FPSProjectile.h"
		
		// Sets default values
		AFPSProjectile::AFPSProjectile()
		{
		 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
			PrimaryActorTick.bCanEverTick = true;
		
			// use a sphere as a simple collision representation
			CollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComponent"));
			// set the sphere's collision radius
			CollisionComponent->InitSphereRadius(15.0f);
			// set the root component to be the collision component
			RootComponent = CollisionComponent;
		}
		
		// Called when the game starts or when spawned
		void AFPSProjectile::BeginPlay()
		{
			Super::BeginPlay();
			
		}
		
		// Called every frame
		void AFPSProjectile::Tick( float DeltaTime )
		{
			Super::Tick( DeltaTime );
		
		}

## Adding a Projectile Movement Component

1.	Locate the `FPSProjectile` class header file in the **Solution Explorer** and open `FPSProjectile.h`.

1.	Add the following code to `FPSProjectile.h`:

		// Projectile movement component
		UPROPERTY(VisibleAnywhere, Category = Movement)
		UProjectileMovementComponent* ProjectileMovementComponent;

1.	`FPSProjectile.h` should now look like the following:

		// Fill out your copyright notice in the Description page of Project Settings.

		#pragma once
		
		#include "GameFramework/Actor.h"
		#include "FPSProjectile.generated.h"
		
		UCLASS()
		class FPSPROJECT_API AFPSProjectile : public AActor
		{
			GENERATED_BODY()
			
		public:	
			// Sets default values for this actor's properties
			AFPSProjectile();
		
			// Called when the game starts or when spawned
			virtual void BeginPlay() override;
			
			// Called every frame
			virtual void Tick( float DeltaSeconds ) override;
		
			// Sphere collision component
			UPROPERTY(VisibleDefaultsOnly, Category = Projectile)
			USphereComponent* CollisionComponent;
			
			// Projectile movement component
			UPROPERTY(VisibleAnywhere, Category = Movement)
			UProjectileMovementComponent* ProjectileMovementComponent;
		};

1.	Locate the `FPSProjectile` CPP file in the **Solution Explorer** and open `FPSProjectile.cpp`.

1.	Add the following lines of code to the `FPSProjectile` constructor in `FPSProjectile.cpp`:

		// Use a ProjectileMovementComponent to govern this projectile's movement
		ProjectileMovement = ObjectInitializer.CreateDefaultSubobject<UProjectileMovementComponent>(this, TEXT("ProjectileComp"));

		if (ProjectileMovement != NULL)
		{
			ProjectileMovement->UpdatedComponent = CollisionComp;
			ProjectileMovement->InitialSpeed = 3000.f;
			ProjectileMovement->MaxSpeed = 3000.f;
			ProjectileMovement->bRotationFollowsVelocity = true;
			ProjectileMovement->bShouldBounce = true;
			ProjectileMovement->Bounciness = 0.3f;
		}

1.	`FPSProjectile.cpp` should now look like the following:

		// Fill out your copyright notice in the Description page of Project Settings.
		
		#include "FPSProject.h"
		#include "FPSProjectile.h"
		
		// Sets default values
		AFPSProjectile::AFPSProjectile()
		{
		 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
			PrimaryActorTick.bCanEverTick = true;
		
			// use a sphere as a simple collision representation
			CollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComponent"));
			// set the sphere's collision radius
			CollisionComponent->InitSphereRadius(15.0f);
			// set the root component to be the collision component
			RootComponent = CollisionComponent;
		
			// use this component to drive this projectile's movement
			ProjectileMovementComponent = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT("ProjectileMovementComponent"));
			ProjectileMovementComponent->SetUpdatedComponent(CollisionComponent);
			ProjectileMovementComponent->InitialSpeed = 3000.0f;
			ProjectileMovementComponent->MaxSpeed = 3000.0f;
			ProjectileMovementComponent->bRotationFollowsVelocity = true;
			ProjectileMovementComponent->bShouldBounce = true;
			ProjectileMovementComponent->Bounciness = 0.3f;
		}
		
		// Called when the game starts or when spawned
		void AFPSProjectile::BeginPlay()
		{
			Super::BeginPlay();
			
		}
		
		// Called every frame
		void AFPSProjectile::Tick( float DeltaTime )
		{
			Super::Tick( DeltaTime );
		
		}

## Setting the Projectile's Initial Velocity

1.	Locate the `FPSProjectile` class header file in the **Solution Explorer** and open `FPSProjectile.h`.

1.	Add the following function declaration in `FPSProjectile.h`:

		// Initiallizes velocity of the projectile in the shoot direction
		void InitVelocity(const FVector& ShootDirection);

	This function will be responsible for launching the projectile.

1.	`FPSProjectile.h` should now look like the following:

		// Fill out your copyright notice in the Description page of Project Settings.
		
		#pragma once
		
		#include "GameFramework/Actor.h"
		#include "FPSProjectile.generated.h"
		
		UCLASS()
		class FPSPROJECT_API AFPSProjectile : public AActor
		{
			GENERATED_BODY()
			
		public:	
			// Sets default values for this actor's properties
			AFPSProjectile();
		
			// Called when the game starts or when spawned
			virtual void BeginPlay() override;
			
			// Called every frame
			virtual void Tick( float DeltaSeconds ) override;
		
			// Sphere collision component
			UPROPERTY(VisibleDefaultsOnly, Category = Projectile)
			USphereComponent* CollisionComponent;
			
			// Projectile movement component
			UPROPERTY(VisibleAnywhere, Category = Movement)
			UProjectileMovementComponent* ProjectileMovementComponent;
		
			// Function that initializes the projectile's velocity in the shoot direction
			void InitVelocity(const FVector& ShootDirection);
		};

1.	Locate the `FPSProjectile` CPP file in the **Solution Explorer** and open `FPSProjectile.cpp`.

1.	Add the following function definition to `FPSProjectile.cpp`:

		// Function that initializes the projectile's velocity in the shoot direction
		void AFPSProjectile::InitVelocity(const FVector& ShootDirection)
		{
			ProjectileMovementComponent->Velocity = ShootDirection * ProjectileMovementComponent->InitialSpeed;
		}

	[REGION:note]
	You only needed to supply a launch direction because the projectile's speed is defined by `ProjectileMovementComponent`.
	[/REGION]

1.	`FPSProjectile.cpp` should now look like the following:

		// Fill out your copyright notice in the Description page of Project Settings.
		
		#include "FPSProject.h"
		#include "FPSProjectile.h"
		
		// Sets default values
		AFPSProjectile::AFPSProjectile()
		{
		 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
			PrimaryActorTick.bCanEverTick = true;
		
			// use a sphere as a simple collision representation
			CollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComponent"));
			// set the sphere's collision radius
			CollisionComponent->InitSphereRadius(15.0f);
			// set the root component to be the collision component
			RootComponent = CollisionComponent;
		
			// use this component to drive this projectile's movement
			ProjectileMovementComponent = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT("ProjectileMovementComponent"));
			ProjectileMovementComponent->SetUpdatedComponent(CollisionComponent);
			ProjectileMovementComponent->InitialSpeed = 3000.0f;
			ProjectileMovementComponent->MaxSpeed = 3000.0f;
			ProjectileMovementComponent->bRotationFollowsVelocity = true;
			ProjectileMovementComponent->bShouldBounce = true;
			ProjectileMovementComponent->Bounciness = 0.3f;
		}
		
		// Called when the game starts or when spawned
		void AFPSProjectile::BeginPlay()
		{
			Super::BeginPlay();
			
		}
		
		// Called every frame
		void AFPSProjectile::Tick( float DeltaTime )
		{
			Super::Tick( DeltaTime );
		
		}
		
		// Function that initializes the projectile's velocity in the shoot direction
		void AFPSProjectile::InitVelocity(const FVector& ShootDirection)
		{
			ProjectileMovementComponent->Velocity = ShootDirection * ProjectileMovementComponent->InitialSpeed;
		}

## Binding the Fire Input Action

1.	Locate the `FPSCharacter` class header file in the **Solution Explorer** and open `FPSCharacter.h`.

1.	Add the following function declaration in `FPSCharacter.h`:

		// handles firing
		UFUNCTION()
		void OnFire();

1.	`FPSCharacter.h` should now look like the following:

		// Fill out your copyright notice in the Description page of Project Settings.
		
		#pragma once
		
		#include "GameFramework/Character.h"
		#include "FPSCharacter.generated.h"
		
		UCLASS()
		class FPSPROJECT_API AFPSCharacter : public ACharacter
		{
			GENERATED_BODY()
		
		public:
			// Sets default values for this character's properties
			AFPSCharacter();
		
			// Called when the game starts or when spawned
			virtual void BeginPlay() override;
			
			// Called every frame
			virtual void Tick( float DeltaSeconds ) override;
		
			// Called to bind functionality to input
			virtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;
		
			// handles moving forward and backward
			UFUNCTION()
			void MoveForward(float Value);
		
			// handles moving right and left
			UFUNCTION()
			void MoveRight(float Value);
		
			// sets jump flag when key is pressed
			UFUNCTION()
			void OnStartJump();
		
			// clears jump flag when key is released
			UFUNCTION()
			void OnStopJump();
		
			// Function that handles firing projectiles
			UFUNCTION()
			void OnFire();
		
			// FPS camera
			UPROPERTY(VisibleAnywhere)
			UCameraComponent* FPSCameraComponent;
		
			// pawn mesh: FPS view (arms are only seen by self)
			UPROPERTY(VisibleDefaultsOnly, Category = Mesh)
			USkeletalMeshComponent* FPSMesh;
		};

1.	Locate the `FPSCharacter` CPP file in the **Solution Explorer** and open `FPSCharacter.cpp`.

1.	In `FPSCharacter.cpp`, add the following code to `SetupPlayerInputComponent` to bind the `OnFire` function:

		// set up projectile fire action binding
		InputComponent->BindAction("Fire", IE_Pressed, this, &AFPSCharacter::OnFire);

1.	Now, add the following function definition to `FPSCharacter.cpp`:

		void AFPSCharacter::OnFire()
		{
		}	

1.	`FPSCharacter.cpp` should now look like the following:

		// Fill out your copyright notice in the Description page of Project Settings.
		
		#include "FPSProject.h"
		#include "FPSCharacter.h"
		
		// Sets default values
		AFPSCharacter::AFPSCharacter()
		{
		 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
			PrimaryActorTick.bCanEverTick = true;
		
			// create a first person camera component
			FPSCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT("FirstPersonCamera"));
			// attach the camera component to our capsule component
			FPSCameraComponent->AttachTo(GetCapsuleComponent());
			// position the camera slightly above the eyes
			FPSCameraComponent->SetRelativeLocation(FVector(0.0f, 0.0f, 50.0f + BaseEyeHeight));
			// allow the pawn to control rotation
			FPSCameraComponent->bUsePawnControlRotation = true;
		
			// create a first person mesh component
			FPSMesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("FirstPersonMesh"));
			// only the owning player sees this mesh
			FPSMesh->SetOnlyOwnerSee(true);
			// attach the FPS mesh to the FPS camera
			FPSMesh->AttachTo(FPSCameraComponent);
			// disable some environmental shadowing to preserve the illusion of having a single mesh
			FPSMesh->bCastDynamicShadow = false;
			FPSMesh->CastShadow = false;
			
			// everyone but you can see the regular body mesh
			GetMesh()->SetOwnerNoSee(true);
		}
		
		// Called when the game starts or when spawned
		void AFPSCharacter::BeginPlay()
		{
			Super::BeginPlay();
			
			const int32 Key = -1;
			static const FString DebugMessage = TEXT("We are using FPSCharacter.");
			FColor DisplayColor = FColor::Red;
			float TimeToDisplay = 5.0f; //seconds
		
			if (GEngine != nullptr)
			{
				GEngine->AddOnScreenDebugMessage(Key, TimeToDisplay, DisplayColor, DebugMessage);
		
			}
		}
		
		// Called every frame
		void AFPSCharacter::Tick( float DeltaTime )
		{
			Super::Tick( DeltaTime );
		
		}
		
		// Called to bind functionality to input
		void AFPSCharacter::SetupPlayerInputComponent(class UInputComponent* InputComponent)
		{
			Super::SetupPlayerInputComponent(InputComponent);
		
			// set up gameplay key bindings
			InputComponent->BindAxis("MoveForward", this, &AFPSCharacter::MoveForward);
			InputComponent->BindAxis("MoveRight", this, &AFPSCharacter::MoveRight);
		
			// set up gameplay mouse bindings
			InputComponent->BindAxis("Turn", this, &AFPSCharacter::AddControllerYawInput);
			InputComponent->BindAxis("LookUp", this, &AFPSCharacter::AddControllerPitchInput);
		
			// set up jump action bindings
			InputComponent->BindAction("Jump", IE_Pressed, this, &AFPSCharacter::OnStartJump);
			InputComponent->BindAction("Jump", IE_Released, this, &AFPSCharacter::OnStopJump);
		
			// set up projectile fire action binding
			InputComponent->BindAction("Fire", IE_Pressed, this, &AFPSCharacter::OnFire);
		}
		
		void AFPSCharacter::MoveForward(float Value)
		{
			// find out which way is forward
			FRotator Rotation = Controller->GetControlRotation();
			// add movement in that direction
			const FVector Direction = FRotationMatrix(Rotation).GetScaledAxis(EAxis::X);
			AddMovementInput(Direction, Value);
		}
		
		void AFPSCharacter::MoveRight(float Value)
		{
			// find out which way is right
			FRotator Rotation = Controller->GetControlRotation();
			// add movement in that direction
			const FVector Direction = FRotationMatrix(Rotation).GetScaledAxis(EAxis::Y);
			AddMovementInput(Direction, Value);
		}
		
		void AFPSCharacter::OnStartJump()
		{
			bPressedJump = true;
		}
		
		void AFPSCharacter::OnStopJump()
		{
			bPressedJump = false;
		}
		
		void AFPSCharacter::OnFire()
		{
		}

## Defining the Projectile's Spawn Location

1.	When spawning the `FPSProjectile` actor, there are two points to consider when implementing the `OnFire` function, namely:

*	Where to spawn the projectile
*	The projectile class (this is so the `FPSCharacter` and its derived Blueprint know what projectile to spawn)

[REGION:note]
You're going to use a camera-space offset vector to determine the projectile's spawn location.
You'll make this parameter editable so that you can set and tweak it in your BP_FPSCharacter Blueprint.
Ultimately, you'll be able to calculate an initial location for the projectile based on this data.
[/REGION]

1.	Locate the `FPSCharacter` class header file in the **Solution Explorer** and open `FPSCharacter.h`.

1.	Add the following code to `FPSCharacter.h`:

		// Gun muzzle's offset from the camera location
		UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)
		FVector MuzzleOffset;

	[REGION:note]
	The EditAnywhere specifier allow you to change the value of the muzzle offset within the Defaults mode of the Blueprint Editor or within the Details tab for any instance of the character. 
	The BlueprintReadWrite specifier allows you to get and set the value of the muzzle offset within a Blueprint.
	[/REGION]

1.	Add the following code to `FPSCharacter.h`:

		// Projectile class to spawn
		UPROPERTY(EditDefaultsOnly, Category = Projectile)
		TSubclassOf<class AFPSProjectile> ProjectileClass;

	[REGION:note]
	The EditDefaultsOnly specifier means that you will only be able to set the projectile class as a default on the Blueprint, not on each instance of the Blueprint.
	[/REGION]

1.	`FPSCharacter.h` should look like the following:

		// Fill out your copyright notice in the Description page of Project Settings.
		
		#pragma once
		
		#include "GameFramework/Character.h"
		#include "FPSCharacter.generated.h"
		
		UCLASS()
		class FPSPROJECT_API AFPSCharacter : public ACharacter
		{
			GENERATED_BODY()
		
		public:
			// Sets default values for this character's properties
			AFPSCharacter();
		
			// Called when the game starts or when spawned
			virtual void BeginPlay() override;
			
			// Called every frame
			virtual void Tick( float DeltaSeconds ) override;
		
			// Called to bind functionality to input
			virtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;
		
			// handles moving forward and backward
			UFUNCTION()
			void MoveForward(float Value);
		
			// handles moving right and left
			UFUNCTION()
			void MoveRight(float Value);
		
			// sets jump flag when key is pressed
			UFUNCTION()
			void OnStartJump();
		
			// clears jump flag when key is released
			UFUNCTION()
			void OnStopJump();
		
			// Function that handles firing projectiles
			UFUNCTION()
			void OnFire();
		
			// FPS camera
			UPROPERTY(VisibleAnywhere)
			UCameraComponent* FPSCameraComponent;
		
			// pawn mesh: FPS view (arms are only seen by self)
			UPROPERTY(VisibleDefaultsOnly, Category = Mesh)
			USkeletalMeshComponent* FPSMesh;
		
			// Gun muzzle's offset from the camera location
			UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)
			FVector MuzzleOffset;
		
			// Projectile class to spawn
			UPROPERTY(EditDefaultsOnly, Category = Projectile)
			TSubclassOf<class AFPSProjectile> ProjectileClass;
		
		};

## Compiling and Checking Your Code

It's now time to compile and check your newly implemented projectile code.

1.	Save all of your interface and implementation files in Visual Studio.

1.	Locate **FPSProject** in the **Solution Explorer**.

1.	Right-click on **FPSProject** and select **Build** to compile your project.

	![](BuildFPSProject.png)

	[REGION:tip]
	The purpose of this step is to catch any build errors before moving onto the next step.
	[/REGION]

%Steps%