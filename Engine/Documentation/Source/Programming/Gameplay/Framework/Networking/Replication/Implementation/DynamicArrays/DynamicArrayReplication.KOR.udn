INTSourceChangelist:2374181
Availability:Public
Title: 동적 배열 리플리케이션
Crumbs:%ROOT%, Gameplay, Gameplay/Networking
Description: 네트워크의 여러 클라이언트에 대한 동적 배열 리플리케이션 입니다.
Version: 4.5

[TOC(start:2 end:3)]

동적 배열 (`TArray`) 의 리플리케이션에는, 효율적으로 만들기 위해 특수한 구현을 요하는 어려움이 따릅니다.
모든 클라이언트에서 배열의 동기화 상태를 유지하기 위해, 배열 내 어떤 부분이 변경되었는지 알아낸 다음
최소한의 데이터만을 네트워크를 통해 전송하는 식으로 이루어집니다.

동적 배열 리플리케이션 프로세스는 일반적인 `UProperty` 리플리케이션 보다 복잡합니다. 
자세한 내용은 [구현](#구현) 부분을 참고해 주세요.

## 동적 배열 리플리케이션 셋업

동적 배열 리플리케이션을 위해서는, 다른 변수에 대해 해 주듯이 리플리케이트된 `TArray` 변수를 선언해 
주기만 하면 됩니다:
	
	/** 정수형 리플리케이트된 TArray */
	UPROPERTY(ReplicatedUsing=OnRep_MyArray)
	TArray<int32> MyArray;

[REGION:note]
`ReplicatedUsing` 키워드를 통해 `OnRep` 함수가 지원됩니다만, 어쨌든 어느 요소가 바뀌었는지는 
알지 못합니다.
[/REGION]

그런 다음 동적 배열이 들어있는 클래스에 대해 `::GetReplicationList()` 함수에서 `DOREPTARRAY` 문을 
추가합니다:

	int32* AMyActor::GetReplicationList( uint8* Recent, FPropertyRetirement* Retire, int32* Ptr, UPackageMap* Map, UActorChannel* Channel, FReplicationFlags RepFlags )
	{
		Ptr = Super::GetReplicationList(Recent, Retire, Ptr, Map, Channel, RepFlags);

		DOREPTARRAY(AMyActor, MyArray);
	
		return Ptr;
	}


## 구현

동적 배열 리플리케이션에는 효율적인 리플리케이션을 위해 특수한 구현을 요하는 어려움이 따릅니다.
커다란 패킷 리플리케이션 외에도, 매번 새로운 `::ReplicateActor` 호출마다 _무엇이 바뀌었는지_ 
알아내는 것과 패킷이 드롭되었을 때 _무엇을 재전송할지_ 알아내는 것이 주요 
과제입니다.

### 데이터 변경
 
표준 `UProperty` 의 경우 무엇이 바뀌었나 알아보는 프로세스는:

* _일반_ `UProperty` 의 변화는 (`TArray<uint8>` 와 같은 한 바이트 배열) _Recent_ 버퍼로 추적됩니다. 
* 버퍼는 액터의 모든 `UProperty` 크기였습니다.
* 프로퍼티 오프셋을 버퍼에 매핑시키기가 쉽습니다.
* 이 배열에 대한 값을 작성하는 데 `CopySingleValue` 를 사용했습니다.
* 날 포인터를 (새/예전 값을 바로 `!=` 비교하기 위해 NEQ 함수를 사용하는 함수) `GetReplicatedProperty` 에 대한 버퍼로 
전해줍니다.


이 방법은 동적 배열만 빼고는 아주 잘 돌아갑니다. 동적 배열 리플리케이션에 대한 효율적인 해법은:

* 동적인 프로퍼티에 대해서는 별도의 버퍼를 유지합니다. `TMap<PropertyID, Byte Buffer >` 
* 특별 케이스 동적 프로퍼티: (크기가 고정된) Recent 버퍼에 읽거나 쓰지 않고, (크기가 유동적인) 동적 버퍼를 대신 사용합니다.
* NEQ 로 새/예전 값을 바로 비교하지 않습니다.
	* 예전 오브젝트 상태의 온전한 사본을 유지해야 하니( 지저분해 지니)까요.
* 그 대신, `NetSerialized` 사본, 즉, 오브젝트를 `NetSerialized` 했을 때 얻는 버퍼를 유지합니다.
* 동적 배열을 항상 Serialize 한 다음, 그 데이터를 예전 상태와 바이트 단위로 비교합니다.
	* 바뀌었으면 전송, 아니면 무시합니다.
  
[REGION:note]
추가적인 Serialize 에 따르는 CPU 비용이 있으나, 이득(에다 동적 배열 프로퍼티가 아닌 것도 같은 속도로 유지되는 것)에 비하면 
그리 나쁜 것은 아닙니다.
[/REGION]
  
괜찮은 개념이지만, 동적 배열 전체 단위가 아니라 요소 단위로 해 줘야 합니다:

* 먼저 `UArrayProperty::NetSerialize` 가 각 요소 인덱스를 Serialize 하게 만듭니다. 이제 Serialize 에서 요소를 건너뛰어도 좋습니다.
* `NetSerializeItemDelta` 라는 새 함수로 최적화된 델타값을 작성하여 `NetSerializeItem` 로 Serialize 시킵니다.
`::ReplicateActor` 는 `UArrayProperty` 특별 케이스로 `NetSerializeItem` 직접 호출 대신 이 함수를 호출합니다.


#### NetSerializeItemDelta

`NetSerializeItemDelta()` 함수는 `NetSerializeItem` 에서 읽을 수 있도록 데이터를 Serialize 하지만, 출력은 
_full_ 상태에 대한 비트 라이터와 _changed_ 상태의 비트 라이터 둘입니다. _old_ 상태에 대한 새 비트 리더 입력도 있어, 
비교할 대상이 있습니다.

`UProperty` 구현이 하는 일은 단순하게도 다음과 같습니다:

* NetSerializeItem 를 통해 프로퍼티를 _full_ 라이터로 Serialize 합니다.
* _old_ 상태 리더와 비교, 변했으면 작성된 상태를 _changed_ 라이터로 복사합니다.


`UArrayProperty` 구현은 더욱 복잡합니다:

* `NetSerializeDelta` 호출로 배열 갯수와 요소를 Serialize 하고, 요소가 바뀌었으면 유지하되, 똑같으면 
(작성했던 요소 인덱스와 마찬가지로) pop 시키고서 다음 요소로 이어갑니다.
* _changed_ 상태를 나가는 번치에 두고서 클라이언트에 전송합니다.
* 다음 `::Replicate` 액터의 diff 에 사용할 수 있도록 서버측의 _full_ 상태를 저장합니다.


### 데이터 재전송

일반 프로퍼티의 경우, 패킷이 드롭되면 서버는 nAck 를 받아 그 패킷이 프로퍼티를 업데이트한 마지막 패킷인지를 
알아봅니다. 업데이트된 이후 (다시 업데이트되지 않은) 프로퍼티는 더티 마킹하여 다음 번 리플리케이트 때 재전송합니다.
이 방법은 변경된 요소만을 찾아 전송해야 하는 배열 프로퍼티에는 통하지 않는데, 이렇게 해서는 프로퍼티를 업데이트했던 
지난 패킷 id 만 추적되어 그 업데이트에 뭐가 바뀌었는지, 그 이후 뭐가 업데이트되었는지 모르기 때문입니다.

이러한 상황을 처리하는 방법은 여러가지 있지만, 간택된 접근법은 대역폭 최소화는 물론 서버 CPU 정상으로 유지하는 
_non-droppy_ 조건을 만족시킵니다:
  
* 델타 번치를 새로 만든 이후, 은퇴 레코드를 가지고 diff 를 만드는 데 사용되었던 예전 기본 상태를 저장합니다.
* nAck 를 받으면, 그 패킷에서 동적 배열을 업데이트했는지 알아봅니다. 그랬다면 현재 기본 상태를 은퇴 레코드에서 
저장했던 것으로 대체합니다. 다음 번 업데이트시, 
잃어버린 diff 를 만들 때 사용했던 기본 상태와의 diff 를 만듭니다.
* 다음 업데이트에는 드롭된 패킷 이후의 모든 업데이트가 포함됩니다.


[REGION:note]
이 방법의 작동을 위해서는 동적 프로퍼티에 대한 은퇴 레코드의 링크드 리스트를 유지해야 합니다. 배열에 새로운 업데이트를 
작성하면서 정상 수신(Ack) 확인된 은퇴 레코드를 해제(free)시켜 줍니다.
[/REGION]
  
좀 더 복잡한 해법으로 어느 패킷을 놓쳤고 받았는지에 따라 최적의 델타를 만들 수도 있습니다.
코드가 복잡해 지는 것은 둘째치고, 희귀한 경우의 대역폭을 줄이는 가능성에 서버의 CPU 부담이 추가되기도 하는 것입니다.
나중에 다룰 수도 있는 문제이지만, 현재로서는 복잡해 지는 것에 비하면 가치 없는 일입니다.

### 비용

동적 배열 리플리케이션 비용은 배열에 따라, 거기에 수행하는 작업에 따라, 네트워크의 퀄리티에 따라 달라집니다.
유념해 둘 요점은:

* **배열 요소 중 변한 것만 전송됩니다.** 항목 수가 엄청 많을 수도 있는 동적 배열 리플리케이션에 필요한 대역폭을 
최소화시키는 데 도움이 됩니다.
* **패킷이 드롭되면, 그 드롭된 패킷 이후 변화된 요소 전부가 재전송됩니다.** 이로써 네트워크 문제로 인한 데이터 
손실을 방지해 주나, 전체적으로 전송되는 데이터의 양이 훨씬 많아질 수는 있습니다.
* **서버가 배열 중간에 요소를 추가하거나 제거한 경우, 변경한 이후의 모든 요소가 재전송됩니다.** 
여기서의 비용은 배열의 크기와 요소가 추가된 곳에 따라 심각해질 수가 있습니다.
* **서버 CPU 부하는 정적 배열보다 동적 배열 전송시 높습니다.** 델타 산출 방식때문에 그러한데, 
동적 배열 내 요소가 바뀌었는지 확인하느라 서버 작업이 추가되기 때문입니다.


## 문제점과 아차싶은 점
 
* **클라이언트에서는 리플리케이트된 배열에 요소를 추가하거나 제거하지 말아야 합니다.** 이것을 감지해낼 수 있는 방법이 
없으며, 배열은 금방 비동기 상태가 됩니다. `TArray` 업데이트는 매우 간단 명료합니다. 서버는( 그리고 클라이언트는) 이럽니다:
	* 현재 배열의 요소는 이만큼이야 (클라이언트가 필요한 만큼 크기를 조절합니다).
	* **요소 X** 가 이 값으로, **요소 Y** 가 저 값으로, 등등 바뀌었어 (클라이언트가 그 값을 설정합니다).
* **클라이언트에서 배열을 shift 하면, 서버에서 그 배열에 완전 새로운 값을 작성하기 전까지는 재동기화시키지 않습니다.**
* **원자성(Atomic) 업데이트는 낱개로(atomically) 리플리케이트 됩니다. 비원자성 업데이트는 무작위 수신될 수가 있습니다.** 
프로퍼티 리플리케이션은 비신뢰성(unreliable) 이므로, 순차 업데이트가 무작위로 일어날 수 있는 것입니다. 배열의 원자성 쓰기는 
자동으로 리플리케이트 됩니다. 배열의 **N** 개 요소를 한 번에 쓴다면, 클라이언트는 **N** 개 업데이트 전부를 한 번에 받습니다. 
그러나 여러 프레임에 걸쳐 임의의 요소를 건드리게 된다면, 순서가 어긋날 수가 있게 되는 것입니다:
	
	예를 들어, 업데이트 1 은 `"Array[0]=X"` 라 하고 업데이트 2 는 `"Array[1]=Y"` 라 합시다. 업데이트 1 이 드롭되었는데 
	클라이언트는 계속해서 업데이트 2 를 받게 되는 경우 `Array[1]=Y` 를 즉시 설정해 버리고 `Array[0]` 은 예전 값 그대로입니다.
	그 후 드롭된 패킷때문에 서버에서는 **negative acknowledgement (nAck)**, 부정 인식이 발동됩니다. 서버가 보기에 클라이언트는 
	업데이트 1 을 잃었으니 기본적으로 `"Array[0]=X 이고 Array[1]=Y"` 이라는 업데이트를 새로 전송합니다.
	(왜 업데이트 1 만 재전송하지 않고 두 값 다 전송해야 하는지는 위의 [구현](#구현) 부분에서 설명했습니다.) 
  
	[REGION:note]
	이는 다른 어떤 리플리케이트된 프로퍼티 집합과도 똑같습니다. 핵심은 그저, 배열의 각 요소는 
	별도의 프로퍼티로 생각해도 된다는 것을 이해하면 됩니다.
	[/REGION]


짧게 요약하면 이렇습니다:

* **프로퍼티 업데이트는 그 속성상 비신뢰성 입니다.** 배열에도 똑같이 적용됩니다.
* **상식을 넘지 않는 선에서.** 배열의 임의 업데이트가 잦은 패턴은 패킷 손실이 정말 심한 경우 대역폭 문제가 정말 
심각해질 수가 있습니다. 절대 그럴 일은 없겠지만, 요소가 1000 개인 배열을 만들거나 했다간 매 프레임마다 임의 요소 
업데이트가 100 개쯤 생길 수도 있다는 점, 유의하시기 바랍니다.
