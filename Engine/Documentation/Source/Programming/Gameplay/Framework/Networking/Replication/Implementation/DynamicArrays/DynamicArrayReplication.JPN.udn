INTSourceChangelist:2122080
Availability:Public
Title:動的配列のレプリケーション
Crumbs:%ROOT%, Gameplay, Gameplay/Networking
Description:ネットワーク上の複数クライアントに動的配列をレプリケーションします。

[TOC(start:2 end:3)]

動的配列のレプリケーション (`TArrays`) を、効率的に行うためには特殊な実装を必要とし、 
ある程度の困難を伴います。これは、動的配列内で何が変更されたかを判断し、 
すべてのクライアントで動的配列が同期するようにネットワーク上に必要最低量のデータだけを送信して行います。

動的配列をレプリケーションするためのプロセスは、通常の`UProperties` よりも複雑です。詳細は 
[実装](#実装) を参照してください 

##動的配列レプリケーションのセットアップ

動的配列をレプリケーションするには、他の変数で行うのと同じように、 
レプリケーションした`TArray` 変数を以下のように宣言します。
	/** A replicated TArray of integers */

	UPROPERTY(ReplicatedUsing=OnRep_MyArray)
	TArray<int32> MyArray;

[REGION:note]
`ReplicatedUsing`キーワードを介して`OnRep`関数がサポートされています。しかし、どのエレメントが変更されたかは 
わかりません。 
[/REGION]

以下のように動的配列を含むクラスに対する `::GetReplicationList()`関数で 
`DOREPTARRAY` 文を追加します。

	int32* AMyActor::GetReplicationList( uint8* Recent, FPropertyRetirement* Retire, int32* Ptr, UPackageMap* Map, UActorChannel* Channel, FReplicationFlags RepFlags )
	{
		Ptr = Super::GetReplicationList(Recent, Retire, Ptr, Map, Channel, RepFlags);

		DOREPTARRAY(AMyActor, MyArray);
	return Ptr;

	}


## 実装

動的配列のレプリケーション (`TArrays`) を、効率的に行うためには特殊な実装を必要とし、 
ある程度の困難を伴います。大量パケットのレプリケーション以外では、 
各新規の`::ReplicateActor` 呼び出しで _何が変更されたか_、パケットがドロップした場合に _何を再送するか_ を見つけることが 
大きな課題でした。

### 変更されたデータ
 
標準の `UProperties` で何が変更されたかを判断するプロセスは以下のようになります。

* _通常の_ `UProperties`の変更は_Recent_ Buffer (単なるバイト配列、すなわち `TArray<uint8>`) で追跡する。 
* バッファはアクタのすべての`UProperties`のサイズであった。 
* プロパティのオフセットをバッファに容易にマッピング。 
* この配列に値を書き込むために`CopySingleValue`を使用した。 
* `GetReplicatedProperty` (新旧の値を直接 `!=`比較するために NEQ 関数を使用した) のために
raw ポインタをバッファに渡した 


これは動的配列以外ではうまく機能します。動的配列を効率的にレプリケーションするには以下の手順に従います。

* 動的プロパティに対して別個のバッファを維持します。`TMap<PropertyID, Byte Buffer >` 
* 特殊ケースの動的プロパティ。Recent バッファ (固定サイズ) から読み出ししたり、そこに書き込んだりせずに、代わりに動的バッファ (任意のサイズ) を使用します。 
* 新旧の値を直接 NEQ で比較しないこと。 
	* 古いオブジェクトのステートのフルコピーを維持し続ける必要がありうる (混乱を招きます) 
* かわりに、`NetSerialized` コピーを維持します。例えば、オブジェクトを`NetSerialized`した場合に得たバッファ。 
* 常に動的配列をシリアル化し、次にシリアル化したデータと以前のステートとをバイト単位で比較します。 
	* 変更されていれば、それを送ります。変更されていなければ無視します。 
  
[REGION:note]
余分にシリアル化すると CPU の負荷は増えますが、利点と比較すれば (非動的配列のプロパティが同じ速度を維持することも加味すると)、 
さほど悪いものではありません。
[/REGION]
  
この考え方は正当なものですが、全体に対して行う代わりに、以下のように動的配列でエレメント単位で行う必要があります。

* 最初に`UArrayProperty::NetSerialize` に各エレメントのインデックスをシリアル化させます。これで、このシリアル化でエレメントをスキップしても大丈夫です。
* 新しい関数、`NetSerializeItemDelta` が必要です。これは、 `NetSerializeItem` によってシリアル化できる最適化されたデルタを書き込みます。 
`::ReplicateActor` は `UArrayProperties` を特別に扱い、 `NetSerializeItem` を直接呼び出す代わりに、これを呼び出します。 


#### NetSerializeItemDelta

`NetSerializeItemDelta()`関数は、 `NetSerializeItem` から読み出すことができるデータをシリアル化しますが、以下の 2 つの出力があります。 
すなわち _フル_ ステート用のビットライターと _変更_ ステート用のビットライターです。_古いステート_ 用の新しいビットリーダーもあるため、 
何かしら比較するものを持っています。

`UProperty`の実装では、以下を行います。

* NetSerializeItem を介してプロパティを _フル_ ライターにシリアル化。
* 古いステート リーダーと比較し、変更されている場合は、書き込まれたステートを _変更された_ ライターにコピーします。 


`UArrayProperty`の実装は以下のようにさらに複雑です。

* 配列番号とエレメントを `NetSerializeDelta` 呼び出しでシリアル化します。エレメントが変更されていればそれを維持します。 
変更がなければ、ポップし (書き込んだエレメント インデックスと合わせて)、次のエレメントに進んで続けます。 
* _変更された_ ステートを送信するものの中に入れて、クライアントに送ります。
* _フル_ ステートをサーバーに保存し、次の `::Replicate` アクタで差分を取るために使用できるようにします。 


###データの再送信

通常のプロパティでは、パケットがドロップすると、サーバーが nAck を受信し、そのパケットが、 
何らかのプロパティが更新された最後のパケットであるかを確認します。更新されたプロパティ (しかもそれ以降更新されていないプロパティ) があればダーティとマークされ、 
次のレプリケーションで再送されます。これは配列のプロパティでは機能しません。更新はどのエレメントが変更されたかのみに基づいて送信され、プロパティを更新した最後のパケットのID のみを追跡し、 
更新で何が変わったか、またはそれ以降何が更新されたかがわからないためです。 

これを処理する方法は数多くありますが、この選択された手法は、通常の _ノンドロップ_ の条件で 
帯域幅とサーバーの CPU を最小限に抑えます。
  
* 新しいデルタの集まりを作成後、その差分を作成するために使用した古いベース ステートをリタイアメント レコードに保存します。 
* nAck を受信したら、そのパケットで動的プロパティを更新したかを確認します。更新した場合は、現在のベース ステートと、 
リタイアメント レコードに保存したものとを置き換えます。 次の更新で、失われた差分を作ったときに使用したベースステートから 
差分を作ります。 
* 次の更新には、ドロップしたパケット以降のすべての更新が含まれます。 


[REGION:note]
これが機能するためには、動的プロパティのためのリタイアメント レコードの連結リストを維持する必要があります。新規更新を配列に書き込むに従い、 
肯定応答 (Ack'd) プロパティであったことを把握しているリタイアメント レコードを解放します。
[/REGION]
  
何のパケットがドロップしたか、何が肯定応答であったかに基づいて最適なデルタを構築できるさらに複雑なソリューションがあります。 
コードが複雑になるだけでなく、サーバーのCPU 負荷も増え、 
こうしたレアケースで帯域幅を節約する可能性があります。これは将来対処する予定ですが、現時点では複雑にすることは価値がありません。 

###コスト

動的配列をレプリケーションするコストは、配列、何のオペレーションをおこなっているか、 
およびネットワークのクオリティによって変わります。覚えておく主要ポイントは以下のとおりです。

* **変更がある配列のエレメントだけを送る** これにより、大量のアイテムを含みうる動的配列をレプリケーションするための 
帯域幅の要件を最小限に抑える支援をします。 
* **パケットがドロップすると、ドロップしたパケット以降に変更されたすべてのエレメントが再送されます。**これにより、ネットワークの問題のためにデータが失われることを防ぎますが、 
全体としてかなり多くのデータが送信されることになります。
* **サーバーが、配列の途中でエレメントを追加または削除すると、その後のすべてのエレメントは変更されて再送されます。** 
配列のサイズとどこでエレメントが追加されたかによって、このコストは高くつく可能性があります。
* **静的配列に比べて動的配列を送信するためには、サーバー側でより多くの CPU オーバーヘッドが生じます。**これは、動的配列でエレメントが変更されたかを確認するために 
サーバー側でより多くの作業を必要とするデルタが機能する仕組みによるものです。


##課題と陥りやすいミス
 
* **クライアント側で、レプリケーションされた配列でエレメントの追加、削除は行わないこと** エレメントの追加、削除を検知するメカニズムはなく、 
配列はどんどん同期がとれなくなります。`TArrays` の更新は非常に単純なものです。サーバー側は以下を伝えます。 
	* 現在、配列の中にあるエレメント数 (必要に応じてクライアントがリサイズします)  
	* **エレメント X** がこの値に変更、**エレメント Y** がこの値に変更など (クライアントがこうした値を設定) 。 
* **クライアント上で配列をシフトする場合、サーバーが全く新しい値を配列に書き込むまでエレメントは再同期しません。**
* **アトミックな更新はアトミックに複製されます。非アトミックな更新は順不同で受信される可能性があります。** プロパティのレプリケーションが信頼できるものではないために、 
順次更新が順不同で行われる可能性があります。配列へのアトミックな書き込みは自動的にレプリケーションします。 
配列に **N** エレメントを一度に書き込むと、クライアントはすべての **N** 更新を	一度に取得します。しかし、 
ランダムなエレメントをタッチしているいくつかのフレームでは、こうしたランダム更新が順不同になる可能性があります。  
	例えば、更新 1 が"Array[0]=X" であり、更新 2 が"Array[1]=Y" である場合を考えます。 

	更新 1 がドロップすると、	クライアントはなおも更新 2 を受信し、`Array[1]=Y`をただちに設定します。`Array[0]`は古い値のまま残ります。 
	続いて、ドロップしたパケットが原因でサーバー上で**否定応答 (nAck)** がトリガーされます。サーバー側は 
	クライアント側で更新1 が欠落していないかを確認し、	基本的に以下の新規更新を送信します。 `"Array[0]=X and Array[1]=Y"` 
	(更新 1 だけを単に再送するのではなく、	なぜ両方の値を送信する必要があるかについては、上記の[実装の詳細](#実装)で説明しています。)  
  
	[REGION:note]
	これはレプリケーションされた他のプロパティのセットと同じです。重要な点は、配列の各要素は 
	別個のプロパティとして	考えられるということを理解することです。
	[/REGION]


簡単に言うと、以下に従う必要があります。 

* **プロパティの更新が信頼できない性質のものであると認識する** これらは配列にも同様に適用されます。 
* **度を超さないこと** 配列を頻繁にランダム更新するというパターンでは、非常に大きなパケット損失があった場合に 
帯域幅の問題に悪影響を及ぼします。おそらくそんなことはないかと思いますが、フレーム毎に 100 のランダムなエレメントを更新する 1000 のエレメントを持つ 
配列を作るようなことはしないでください。 

