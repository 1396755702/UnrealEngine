// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

#include "SequenceRecorderPrivatePCH.h"
#include "ActorRecording.h"
#include "SequenceRecorderSettings.h"
#include "SequenceRecorderUtils.h"

bool UActorRecording::StartRecording()
{
	LastRecordedAnimation = nullptr;

	if(ActorToRecord.IsValid())
	{
		// @todo: animation recording: allow recording of multiple skeletal meshes per actor
		USkeletalMeshComponent* SkeletalMeshComponent = ActorToRecord.Get()->FindComponentByClass<USkeletalMeshComponent>();
		if(SkeletalMeshComponent)
		{
			// turn off URO and make sure we always update even if out of view
			bEnableUpdateRateOptimizations = SkeletalMeshComponent->bEnableUpdateRateOptimizations;
			MeshComponentUpdateFlag = SkeletalMeshComponent->MeshComponentUpdateFlag;

			SkeletalMeshComponent->bEnableUpdateRateOptimizations = false;
			SkeletalMeshComponent->MeshComponentUpdateFlag = EMeshComponentUpdateFlag::AlwaysTickPoseAndRefreshBones;

			UAnimSequence* Sequence = nullptr;
			const bool bValidSpecifiedAnimation = (bSpecifyTargetAnimation && TargetAnimation.IsValid());
			if(bValidSpecifiedAnimation)
			{
				Sequence = TargetAnimation.Get();
			}

			bool bValidAutoGeneratedAnimation = false;
			if(!bSpecifyTargetAnimation)
			{
				// build an asset path
				const USequenceRecorderSettings* Settings = GetDefault<USequenceRecorderSettings>();

				FString AssetPath(TEXT("/Game"));
				AssetPath /= Settings->SequenceRecordingBasePath.Path;
				if(Settings->AnimationSubDirectory.Len() > 0)
				{
					AssetPath /= Settings->AnimationSubDirectory;
				}

				FString AssetName = Settings->SequenceName.Len() > 0 ? Settings->SequenceName : TEXT("RecordedSequence");
				AssetName += TEXT("_");
				AssetName += ActorToRecord->GetActorLabel();

				Sequence = SequenceRecorderUtils::MakeNewAsset<UAnimSequence>(AssetPath, AssetName);
				if(Sequence)
				{
					// set skeleton
					Sequence->SetSkeleton(SkeletalMeshComponent->SkeletalMesh->Skeleton);
					bValidAutoGeneratedAnimation = true;
				}
			}

			if(bValidSpecifiedAnimation || bValidAutoGeneratedAnimation)
			{
				FAnimationRecorderManager::Get().RecordAnimation(SkeletalMeshComponent, Sequence, AnimationSettings);
				LastRecordedAnimation = Sequence;
				return true;
			}
		}
	}

	return false;
}

void UActorRecording::Tick(float DeltaSeconds)
{
	if (ActorToRecord.IsValid())
	{
		USkeletalMeshComponent* SkeletalMeshComponent = ActorToRecord.Get()->FindComponentByClass<USkeletalMeshComponent>();
		if (SkeletalMeshComponent)
		{
			// re-force updates on as gameplay can sometimes turn these back off!
			SkeletalMeshComponent->bEnableUpdateRateOptimizations = false;
			SkeletalMeshComponent->MeshComponentUpdateFlag = EMeshComponentUpdateFlag::AlwaysTickPoseAndRefreshBones;
		}
	}
}

bool UActorRecording::StopRecording()
{
	if (ActorToRecord.IsValid())
	{
		// @todo: animation recording: allow recording of multiple skeletal meshes per actor
		USkeletalMeshComponent* SkeletalMeshComponent = ActorToRecord.Get()->FindComponentByClass<USkeletalMeshComponent>();
		if (SkeletalMeshComponent)
		{
			// restore update flags
			SkeletalMeshComponent->bEnableUpdateRateOptimizations = bEnableUpdateRateOptimizations;
			SkeletalMeshComponent->MeshComponentUpdateFlag = MeshComponentUpdateFlag;

			FAnimationRecorderManager::Get().StopRecordingAnimation(SkeletalMeshComponent);
			return true;
		}
	}

	return false;
}

bool UActorRecording::IsRecording() const
{
	if(ActorToRecord.IsValid())
	{
		USkeletalMeshComponent* SkeletalMeshComponent = ActorToRecord.Get()->FindComponentByClass<USkeletalMeshComponent>();
		if (SkeletalMeshComponent)
		{
			return FAnimationRecorderManager::Get().IsRecording(SkeletalMeshComponent);
		}
	}

	return false;
}
